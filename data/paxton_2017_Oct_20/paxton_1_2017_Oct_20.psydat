ccopy_reg
_reconstructor
p1
(cpsychopy.data
ExperimentHandler
p2
c__builtin__
object
p3
NtRp4
(dp5
S'originPath'
p6
NsS'dataFileName'
p7
Vdata/paxton_2017_Oct_20/paxton_1_2017_Oct_20
p8
sS'runtimeInfo'
p9
NsS'name'
p10
S'Posner'
p11
sS'dataNames'
p12
(lp13
sS'autoLog'
p14
I01
sS'extraInfo'
p15
(dp16
S'probeFrames'
p17
I12
sS'run'
p18
S'4'
sS'cuePos'
p19
I10
sS'fixFrames'
p20
I90
sS'memFrames'
p21
I60
sS'cueFrames'
p22
I30
sS'dateStr'
p23
V2017_Oct_20
p24
sS'probePos'
p25
I10
sS'participant'
p26
Vpaxton
p27
sS'cuePauseFrames'
p28
I12
sS'memPauseFrames'
p29
I60
ssS'loopsUnfinished'
p30
(lp31
g1
(cpsychopy.data
TrialHandler
p32
g3
NtRp33
(dp34
S'origin'
p35
Vfrom psychopy import visual, event, core, data, gui, logging\u000aimport random\u000aimport os\u000aimport pickle\u000a\u000avers = '2.0'\u000a\u000a\u000a####### PARAMS + SUB INFO #########\u000a\u000a# clocks\u000aglobalClock = core.Clock()\u000alogging.setDefaultClock(globalClock)\u000a\u000a# objects sizes\u000afixationSize = 0.5\u000aprobeSize = 7\u000acueSize = 1\u000a\u000a# nuber of runs\u000arepetitions = 3\u000a\u000a# info dictionary\u000ainfo = {}\u000ainfo['participant'] = ''\u000ainfo['run'] = ''\u000adlg = gui.DlgFromDict(info)\u000aif not dlg.OK:\u000a    core.quit()\u000ainfo['dateStr']= data.getDateStr()[0:11]\u000a\u000a\u000a# subject directory\u000adir_name = info['participant'] + '_' + info['dateStr']\u000adir_check = 'data/' + dir_name\u000a\u000a# if subject directory does not exist, create it\u000aif not os.path.exists(dir_check):\u000a    os.makedirs(dir_check)\u000a\u000a# filenames \u000afilename = "data/" + dir_name + '/'+ info['participant'] + '_' + info['run'] + '_' + info['dateStr'] \u000alogFileName = "data/" + dir_name + '/' + info['participant'] + '_' + info['run'] + '_' + info['dateStr'] + '.log'\u000a\u000a\u000a# stim dirs\u000adir1 = 'selected_images/'\u000adir2 = 'gray_scene/'\u000a\u000a#instructions \u000ainstructPractice = 'Practice about to start. Press RETURN when ready'\u000ainstructExp = 'Experiment about to start. Press RETURN when ready'\u000ainstructMem = 'Memory task about to start. Press RETURN when ready'\u000ainstructThanks = 'Thank you for your participation!'\u000a\u000a#logging\u005cdebugging preferences\u000aDEBUG = False\u000a\u000aif DEBUG:\u000a    fullscr = False\u000a    logging.console.setLevel(logging.DEBUG)\u000aelse:\u000a    fullscr = True\u000a    logging.console.setLevel(logging.WARNING)\u000a\u000alogDat = logging.LogFile (logFileName, filemode='w', level = logging.DATA)\u000a\u000a\u000a\u000a# create window\u000awin = visual.Window([1024,768], fullscr = True, monitor = 'testMonitor', units='deg', color = 'black')\u000a\u000a# obtain frame rate\u000afRate_secs = win.getActualFrameRate()\u000aprint(fRate_secs)\u000a\u000a# set stim display durations\u000ainfo['fixFrames'] = int(round(1.5 * fRate_secs))\u000ainfo['cueFrames'] = int(round(.5 * fRate_secs))\u000ainfo['cuePauseFrames'] = int(round(.2* fRate_secs))\u000ainfo['probeFrames'] = int(round(.2 * fRate_secs))\u000ainfo['cuePos'] = 10\u000ainfo['probePos'] = 10\u000ainfo['memFrames'] = int(round(1 * fRate_secs))\u000a#info['ratingFrames'] = int(round(1 *  fRate_secs))\u000a#^^change this in the rating settings\u000ainfo['memPauseFrames'] = int(round(1 *fRate_secs))\u000a\u000a#create objects\u000afixation = visual.Circle(win, size = fixationSize, lineColor = 'white', fillColor = 'lightGrey')\u000acueVerticesR = [[-.8,-.5], [-.8,.5], [.8,0]]\u000acueRight = visual.ShapeStim(win, vertices = cueVerticesR, lineColor = 'white', fillColor = 'lightGrey')\u000acueVerticesL = [[.8,-.5], [.8,.5], [-.8,0]]\u000acueLeft = visual.ShapeStim(win, vertices = cueVerticesL, lineColor = 'white', fillColor = 'lightGrey')\u000a#cue = visual.Circle(win, size = cueSize, lineColor = 'white', fillColor = 'lightGrey')\u000ainstruction = visual.TextStim(win)\u000a\u000a#import conditions from csv\u000a#should be an even number\u000aconditions = data.importConditions('conditions_short.csv') \u000a#\u000a# KZ : ^ideally run independent of csv file (low priority)\u000a#      currently, csv gives us only # of trials\u000a#\u000atrials = data.TrialHandler(trialList = conditions, nReps = 1)\u000a\u000a##########################################################\u000a\u000a#define practice run (same length as full run)\u000aconditionsPractice = data.importConditions('conditions_short.csv')\u000apractice = data.TrialHandler(trialList = conditionsPractice, nReps = 1)\u000a\u000athisExp = data.ExperimentHandler(name='Posner', version= vers, #not needed, just handy\u000a    extraInfo = info, #the info we created earlier\u000a    dataFileName = filename, # using our string with data/name_date\u000a    )\u000a\u000athisExp.addLoop(trials)\u000athisExp.addLoop(practice)\u000a\u000arespClock = core.Clock()\u000a\u000a\u000a\u000a####### FILE LOAD FUNCTIONS #########\u000a\u000adef get_files(dir_name):\u000a    '''returns all subj pkl files'''\u000a    files = [dir_name + '/' + f for f in os.listdir(dir_name) if f.endswith('.pkl')]\u000a    return files\u000a    \u000adef concat_dicts(dicts):\u000a    big_dict = {}\u000a    for k in dicts[0]:\u000a        big_dict[k] = [d[k] for d in dicts]\u000a    return big_dict\u000a\u000adef load_memP(pickles):\u000a    ''' returns list of memory pkl dicts'''\u000a    mem = []\u000a    for f in pickles:\u000a        if f.endswith('mem_items.pkl'):\u000a            mem.append(f)\u000a            \u000a    mem_dicts = []\u000a    for memf in mem:\u000a        with open(memf, 'rb') as fp:\u000a            x=pickle.load(fp)\u000a        mem_dicts.append(x)\u000a    mem_dict = concat_dicts(mem_dicts)\u000a    return mem_dict\u000a    \u000a    \u000adef load_prevP(pickles):\u000a    '''returns list of prev pkl files'''\u000a    prev = []\u000a    for f in pickles:\u000a        if f.endswith('previous_items.pkl'):\u000a            prev.append(f)\u000a\u000a            \u000a    prev_dicts = []\u000a    for prevf in prev:\u000a        with open(prevf, 'rb') as fp:\u000a            y=pickle.load(fp)\u000a        prev_dicts.append(y)\u000a    prev_dict = concat_dicts(prev_dicts)\u000a    return prev_dict\u000a    \u000a############ EXP FUNCTIONS ############\u000a\u000adef showInstructions(text, acceptedKeys = None):\u000a    """Presents a question and waits for acceptedKeys"""\u000a    \u000a    # Set and display text\u000a    instruction.setText(text)\u000a    instruction.draw()\u000a    win.flip()\u000a    \u000a    # Wait for response and return it\u000a    response = event.waitKeys(keyList=acceptedKeys)\u000a    #return response\u000a    if response == 'escape':\u000a        core.quit()\u000a\u000a\u000adef presBlock( pickle_name, prev_stim, run, loop = object, saveData = True, test=True):\u000a\u000a    """Runs a loop for an experimental block and saves reponses if requested"""\u000a    \u000a    trialClock = core.Clock()\u000a    \u000a    previous_items = {}\u000a    cued = []\u000a    uncued = []\u000a    cue_right = []\u000a    \u000a    reaction_time={}\u000a    cued_RT = []\u000a    uncued_RT = []\u000a    \u000a    trial_count = 0\u000a    \u000a    for thisTrial in loop:\u000a        \u000a        trial_count += 1\u000a        \u000a        # [1] CUE ONE SIDE\u000a        \u000a        #randomize side\u000a        if bool(random.getrandbits(1)) == True:\u000a            cue = cueRight\u000a            cue_right.append(1)\u000a\u000a        else:\u000a            cue = cueLeft\u000a            cue_right.append(0)\u000a            \u000a        cue.setPos( [0, 0] )\u000a        \u000a        #show fixation\u000a        fixation.setAutoDraw(True)\u000a        for frameN in range(info['fixFrames']):\u000a            win.flip()\u000a        \u000a        #show cue\u000a        cue.setAutoDraw(True)\u000a        for frameN in range(info['cueFrames']):\u000a            win.flip()\u000a        cue.setAutoDraw(False) \u000a        \u000a        #pause\u000a        for frameN in range(info['cuePauseFrames']):\u000a            fixation.setAutoDraw(True)\u000a            win.flip()\u000a        \u000a        # [2] DETERMINE TRIAL TYPE (STANDARD vs CATCH)\u000a        #trialType = random.choice([1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2])\u000a\u000a        # [3] RUN TRIAL\u000a        all_items = os.listdir(dir1)+os.listdir(dir2)\u000a        available_items = [x for x in all_items if (x not in cued and x not in uncued and x not in prev_stim)]\u000a            \u000a        #select and load image stimuli at random\u000a        #select and load image stimuli at random\u000a        img1_file = random.choice([x for x in available_items if x in os.listdir(dir1)])\u000a        img1 = dir1+img1_file\u000a        img2_file = img1_file\u000a           \u000a        while (img2_file == img1_file):\u000a            img2_file = random.choice([x for x in available_items if x in os.listdir(dir2)])\u000a            \u000a        img2 = dir2 + img2_file\u000a        \u000a        #assign images as probes (w/ sizes, locations, etc.)\u000a        if random.choice([0,1])==True:\u000a            probe1 = visual.ImageStim(win, img1, size=probeSize) #pos=(5, 0), size=probeSize)\u000a            probe2 = visual.ImageStim(win, img2, size=probeSize) #pos=(-5, 0), size=probeSize)\u000a        else:\u000a            probe2 = visual.ImageStim(win, img1, size=probeSize) #pos=(5, 0), size=probeSize)\u000a            probe1 = visual.ImageStim(win, img2, size=probeSize) #pos=(-5, 0), size=probeSize)\u000a        \u000a        probePos = random.choice([1,2])\u000a        \u000a        if probePos == 1:\u000a            pos1 = info['probePos']\u000a            pos2 = -info['probePos']\u000a            \u000a        else:\u000a            pos1 = -info['probePos']\u000a            pos2 = info['probePos']\u000a         \u000a        probe1.setPos([pos1, 0])\u000a        probe2.setPos([pos2, 0])\u000a         \u000a        if (cue == cueRight and pos1 > 0) :\u000a            cued.append(img1_file)\u000a            uncued.append(img2_file)\u000a        else:\u000a            cued.append(img2_file)\u000a            uncued.append(img1_file)\u000a        \u000a        #response and reaction time variables\u000a        resp = None\u000a        rt = None\u000a        \u000a        #display probes simultaneously\u000a        probe1.setAutoDraw(True)\u000a        probe2.setAutoDraw(True)\u000a        win.callOnFlip(respClock.reset)\u000a        event.clearEvents()\u000a        for frameN in range(info['probeFrames']):\u000a            if frameN == 0:\u000a                respClock.reset()\u000a            win.flip()\u000a        probe1.setAutoDraw(False)\u000a        probe2.setAutoDraw(False)\u000a        fixation.setAutoDraw(False)\u000a    \u000a        #clear screen\u000a        win.flip()\u000a        \u000a            #KZ : code below from the original repo\u000a            #     maybe useful format for saving\u000a            #####################################\u000a#                trials.addData('resp', resp)\u000a#                trials.addData('rt', rt)\u000a#                trials.addData('corr', corr)\u000a#                thisExp.nextEntry()\u000a            #####################################\u000a                \u000a             \u000a            \u000a        #if trialType == 1: #if catch trial (30% chance):\u000a                #pause\u000a                \u000a        #for frameN in range(info['cuePauseFrames']):\u000a            #win.flip()\u000a\u000a        resp = None\u000a        rt = None\u000a        \u000a        probe = visual.TextStim(win=win, ori=0, name='fixation', text='+', font='Arial', height = 5.5, color='lightGrey', colorSpace='rgb', opacity=1, depth=0.0)\u000a        if cue == cueRight:\u000a            position = random.choice( [-10, -10, -10, 10, 10, 10, 10, 10, 10, 10] )\u000a        else:\u000a            position = random.choice( [10, 10, 10, -10, -10, -10, -10, -10, -10, -10] )\u000a        probe.setPos( [position, 0] )\u000a        #display probe, break is response recorded\u000a        fixation.setAutoDraw(True)\u000a        probe.setAutoDraw(True)\u000a        win.callOnFlip(respClock.reset)\u000a        event.clearEvents()\u000a        for frameN in range(info['probeFrames']):\u000a            #fixation.setAutoDraw(True)\u000a            #probe.setAutoDraw(True)\u000a            if frameN == 0:\u000a                respClock.reset()\u000a                keys = event.getKeys(keyList = ['enter'])\u000a                if len(keys) > 0:\u000a                    resp = keys[0]\u000a                    rt = respClock.getTime()\u000a                    break\u000a                    \u000a            #clear screen\u000a            win.flip()\u000a            probe.setAutoDraw(False)\u000a            fixation.setAutoDraw(False)\u000a\u000a            #if no response, wait w/ blank screen until response\u000a            if (resp == None and test==False):\u000a                keys = event.waitKeys(keyList = ['1', '3'])\u000a                resp = keys[0]\u000a                rt = respClock.getTime()\u000a            \u000a            elif (resp == None and test == True):\u000a                rt = 'test'\u000a                \u000a            # KZ : reaction times saved below\u000a            #      currently saves two groups: cued/uncued\u000a            #      change to save into four:\u000a            #           2 (cued/uncued) * 2 (right/left) = 4\u000a            \u000a        if ( cue == cueRight and position > 1 ):\u000a            cued_RT.append(rt)\u000a            \u000a        else:\u000a            uncued_RT.append(rt)\u000a            #target_right.append(0)\u000a            #clear screen upon response\u000a            win.flip()\u000a            \u000a\u000a            #KZ : code below from the original repo\u000a            #     maybe useful format for saving\u000a            #####################################\u000a#                trials.addData('resp', resp)\u000a#                trials.addData('rt', rt)\u000a#                trials.addData('corr', corr)\u000a#                thisExp.nextEntry()\u000a            #####################################\u000a                \u000a        win.flip()\u000a    \u000a    previous_items['cued'] = cued\u000a    previous_items['uncued'] = uncued\u000a    previous_items['uncued_RT'] = uncued_RT\u000a    previous_items['cued_RT'] = cued_RT\u000a    previous_items['cued_RT'] = cued_RT\u000a    previous_items['cue_Right'] = cue_right\u000a    previous_items['run_time'] = trialClock.getTime()\u000a    previous_items['total_iters'] = trial_count\u000a    \u000a    # KZ : code below saves data in pickle format\u000a    #      if we save data per trial (we should, even if not needed; want a record of everything subject saw at each moment) \u000a    #      we will need to incorporate trial # and subject # into filenames\u000a    \u000a    #      should set up experiment so that if subject is on run 1, it makes new directory for subject\u000a    #      other runs --> check for directory --> if exists, save out to subj dir --> if not exist..warning? create subject direcotry?\u000a    \u000a    with open(pickle_name, 'wb') as f:\u000a        pickle.dump(previous_items, f)\u000a\u000a\u000a\u000a\u000a\u000adef memBlock( conds, current_pickle, prev_stim ):\u000a    trialClock = core.Clock()\u000a    \u000a    # start dictionary to store data\u000a    mem_task = {}\u000a    \u000a    # filename for saved output\u000a    pickle_name_mem = "data/" + dir_name + '/' + info['participant'] + '_' + info['run'] + '_' + info['dateStr'] + 'mem_items.pkl'\u000a    \u000a    #KZ : reads in the pickle file\u000a    with open(current_pickle,'rb') as fp:\u000a        current_list = pickle.load(fp)\u000a        #previous_items_full = [val for sublist in previous_items for val in sublist]\u000a    \u000a    \u000a    # empty list to store items used in memory task\u000a    previous_mem = []\u000a    all_ratings = []\u000a    \u000a    \u000a    for each in conds:\u000a        \u000a        all_items = os.listdir(dir1)+os.listdir(dir2)\u000a        available_attended = [x for x in current_list['cued'] if x not in previous_mem]\u000a        available_unattended = [x for x in current_list['uncued'] if x not in previous_mem]\u000a        available_random = [x for x in all_items if (x not in previous_mem and x not in current_list['cued'] and x not in current_list['uncued'] and x not in prev_stim)]\u000a        \u000a        #select and load image stimuli \u000a        #options = [ 1, 2, 3]\u000a        options = []\u000a        if len(available_attended)>0:\u000a            options.append(1)\u000a        if len(available_unattended)>0:\u000a            options.append(2)\u000a        if len(available_random)>0:\u000a            options.append(3)\u000a        \u000a        # if we decide not to show all images then will want to show Rpres and Lpres with same frequency\u000a        type = random.choice(options)\u000a        \u000a        if type == 1:\u000a            mem_file = random.choice(available_attended)\u000a        elif type == 2:\u000a            mem_file = random.choice(available_unattended)\u000a        else:\u000a            mem_file = random.choice(available_random)\u000a        \u000a        try:\u000a            #Type = 'Faces'\u000a            #mem = '/Users/kirstenziman/Documents/GitHub/P4N2016/stim/OddballLocStims/'+Type+'/'+mem_file\u000a            mem = dir1 + mem_file\u000a            memProbe = visual.ImageStim( win, mem, size=probeSize )\u000a            memProbe.setPos( [0, 0] )\u000a            \u000a        except:\u000a            #Type = 'Houses'\u000a            #mem = '/Users/kirstenziman/Documents/GitHub/P4N2016/stim/OddballLocStims/'+Type+'/'+mem_file\u000a            mem = dir2 + mem_file\u000a            memProbe = visual.ImageStim( win, mem, size=probeSize )\u000a            memProbe.setPos( [0, 0] )\u000a\u000a        \u000a        win.callOnFlip(respClock.reset)\u000a        event.clearEvents()\u000a\u000a        for frameN in range(info['memFrames']):\u000a            memProbe.setAutoDraw(True)\u000a            if frameN == 0:\u000a                respClock.reset()\u000a            win.flip()\u000a        memProbe.setAutoDraw(False)\u000a        win.flip()\u000a        \u000a#        for frameN in range(info['memFrames']):\u000a#            memProbe.setAutodraw(True)\u000a#        win.flip()\u000a        \u000a        ratingScale = visual.RatingScale( win, low = 1, high = 4, labels = ['viewed before','new image'], scale = None, pos = [0,0],acceptPreText='', maxTime=1.0, singleClick=True)\u000a        \u000a        ##################\u000a\u000a        while ratingScale.noResponse:\u000a            #item.draw()\u000a            ratingScale.draw()\u000a            win.flip()\u000a        choiceHistory = ratingScale.getHistory()\u000a\u000a        for frameN in range(info['memPauseFrames']):\u000a            fixation.setAutoDraw(True)\u000a            win.flip()\u000a        fixation.setAutoDraw(False)\u000a\u000a        # KZ : need to save decisionTime and choiceHistory\u000a        #      need to save decisionTime grouped by type of image subj is responding to\u000a        #      10 image types : 1 (seen) * 2 (attended/unattended) * 2 (displayed right/left) * 2 (face/house)  +  1 (unseen) * 2 (face/house)\u000a        \u000a        previous_mem.append(mem_file)\u000a        all_ratings.append(choiceHistory)\u000a    \u000a    mem_task['ratings'] = all_ratings\u000a    mem_task['images'] = previous_mem\u000a    mem_task['run_time'] = trialClock.getTime()\u000a    mem_task['total_iters'] = conds\u000a    #mem_task['choiceHist']=all_ratings\u000a\u000a    with open(pickle_name_mem, 'wb') as f:\u000a        pickle.dump(mem_task, f)\u000a        \u000a        \u000a        \u000a######### RUN EXPERIMENT ###########\u000a\u000a# for specified number of reps, run presentation them memory\u000afor rep in range(0,repetitions):\u000a    \u000a    #pickle_name for use in both functions\u000a    pickle_name = "data/" + dir_name + '/' + info['participant'] + '_' + info['run'] + '_' + info['dateStr'] + 'previous_items.pkl'\u000a    \u000a    # if pkl files exist from previous runs, load the data\u000a    prev_runs = []\u000a    files = get_files(dir_check)\u000a    if len(files)>0:\u000a        mem_dict = load_memP(files)\u000a        prev_dict = load_prevP(files)\u000a        \u000a        prev_stim = mem_dict['images']\u000a        prev_stim.append(prev_dict['cued'])\u000a        prev_stim.append(prev_dict['uncued'])\u000a        prev_stim = [val for sublist in prev_stim for val in sublist]\u000a    else:\u000a        prev_stim = []\u000a    #prev_stim list of all images shown BEFORE THIS TRIAL\u000a        \u000a    # load trials\u000a    conditions = data.importConditions('conditions_short.csv') \u000a    trials = data.TrialHandler(trialList = conditions, nReps = 1)\u000a\u000a    #presentation task\u000a    showInstructions(text = instructExp, acceptedKeys = ['1','2','3','4','return', 'escape'])\u000a    presBlock(pickle_name, prev_stim, info['run'], trials, test=False)\u000a#    presBlock(info['run'], trials)\u000a\u000a    #memory task\u000a    showInstructions(text = instructMem, acceptedKeys = ['1','2','3','4','return'])\u000a    memBlock(range(0,len(conditions)*3), pickle_name, prev_stim)\u000a    \u000a    info['run'] = str(int(info['run'])+1)\u000a\u000a#closing message\u000ashowInstructions(text = instructThanks, acceptedKeys = ['1','2','3','4','return'])
p36
sS'thisTrial'
p37
(lp38
sS'_exp'
p39
I328834448
sg10
S''
sg6
S'/Users/Student/Desktop/Kirsten_testing/pilot_temp.py'
p40
sS'thisRepN'
p41
I0
sg14
I01
sg15
NsS'data'
p42
g1
(cpsychopy.data
DataHandler
p43
c__builtin__
dict
p44
(dp45
S'ran'
p46
cnumpy.ma.core
_mareconstruct
p47
(cnumpy.ma.core
MaskedArray
p48
cnumpy
ndarray
p49
(I0
tp50
S'b'
tRp51
(I1
(I20
I1
tcnumpy
dtype
p52
(S'f4'
I0
I1
tRp53
(I3
S'<'
NNNI-1
I-1
I0
tbI00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
NtbsS'order'
p54
g47
(g48
g49
g50
S'b'
tRp55
(I1
(I20
I1
tg53
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01'
NtbstRp56
(dp57
S'isNumeric'
p58
(dp59
g46
I01
sg54
I01
ssS'trials'
p60
g33
sS'dataTypes'
p61
(lp62
g46
ag54
asS'dataShape'
p63
(lp64
I20
aI1
asbsS'method'
p65
S'random'
p66
sS'sequenceIndices'
p67
cnumpy.core.multiarray
_reconstruct
p68
(g49
(I0
tS'b'
tRp69
(I1
(I20
I1
tg52
(S'i4'
I0
I1
tRp70
(I3
S'<'
NNNI-1
I-1
I0
tbI01
S'\x03\x00\x00\x00\t\x00\x00\x00\x0c\x00\x00\x00\x11\x00\x00\x00\x0e\x00\x00\x00\r\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x06\x00\x00\x00\x05\x00\x00\x00\x12\x00\x00\x00\x07\x00\x00\x00\x0f\x00\x00\x00\x0b\x00\x00\x00\x04\x00\x00\x00\x08\x00\x00\x00\x01\x00\x00\x00\n\x00\x00\x00\x13\x00\x00\x00'
tbsS'finished'
p71
I00
sS'nReps'
p72
I1
sS'nRemaining'
p73
I20
sS'trialList'
p74
(lp75
g1
(cpsychopy.data
TrialType
p76
g44
(dp77
S'other'
p78
S'right'
p79
sS'probeX'
p80
cnumpy.core.multiarray
scalar
p81
(g52
(S'i8'
I0
I1
tRp82
(I3
S'<'
NNNI-1
I-1
I0
tbS'\x08\x00\x00\x00\x00\x00\x00\x00'
tRp83
sS'valid'
p84
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp85
sS'cueOri'
p86
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp87
stRp88
ag1
(g76
g44
(dp89
g78
S'left'
p90
sg80
g81
(g82
S'\xf8\xff\xff\xff\xff\xff\xff\xff'
tRp91
sg84
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp92
sg86
g81
(g82
S'\xb4\x00\x00\x00\x00\x00\x00\x00'
tRp93
stRp94
ag1
(g76
g44
(dp95
g78
g79
sg80
g81
(g82
S'\x08\x00\x00\x00\x00\x00\x00\x00'
tRp96
sg84
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp97
sg86
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp98
stRp99
ag1
(g76
g44
(dp100
g78
g90
sg80
g81
(g82
S'\xf8\xff\xff\xff\xff\xff\xff\xff'
tRp101
sg84
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp102
sg86
g81
(g82
S'\xb4\x00\x00\x00\x00\x00\x00\x00'
tRp103
stRp104
ag1
(g76
g44
(dp105
g78
S'conflict'
p106
sg80
g81
(g82
S'\x08\x00\x00\x00\x00\x00\x00\x00'
tRp107
sg84
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp108
sg86
g81
(g82
S'\xb4\x00\x00\x00\x00\x00\x00\x00'
tRp109
stRp110
ag1
(g76
g44
(dp111
g78
g106
sg80
g81
(g82
S'\xf8\xff\xff\xff\xff\xff\xff\xff'
tRp112
sg84
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp113
sg86
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp114
stRp115
ag1
(g76
g44
(dp116
g78
g90
sg80
g81
(g82
S'\xf8\xff\xff\xff\xff\xff\xff\xff'
tRp117
sg84
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp118
sg86
g81
(g82
S'\xb4\x00\x00\x00\x00\x00\x00\x00'
tRp119
stRp120
ag1
(g76
g44
(dp121
g78
g79
sg80
g81
(g82
S'\x08\x00\x00\x00\x00\x00\x00\x00'
tRp122
sg84
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp123
sg86
g81
(g82
S'\xb4\x00\x00\x00\x00\x00\x00\x00'
tRp124
stRp125
ag1
(g76
g44
(dp126
g78
g79
sg80
g81
(g82
S'\x08\x00\x00\x00\x00\x00\x00\x00'
tRp127
sg84
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp128
sg86
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp129
stRp130
ag1
(g76
g44
(dp131
g78
g90
sg80
g81
(g82
S'\xf8\xff\xff\xff\xff\xff\xff\xff'
tRp132
sg84
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp133
sg86
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp134
stRp135
ag1
(g76
g44
(dp136
g78
g79
sg80
g81
(g82
S'\x08\x00\x00\x00\x00\x00\x00\x00'
tRp137
sg84
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp138
sg86
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp139
stRp140
ag1
(g76
g44
(dp141
g78
g90
sg80
g81
(g82
S'\xf8\xff\xff\xff\xff\xff\xff\xff'
tRp142
sg84
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp143
sg86
g81
(g82
S'\xb4\x00\x00\x00\x00\x00\x00\x00'
tRp144
stRp145
ag1
(g76
g44
(dp146
g78
g79
sg80
g81
(g82
S'\x08\x00\x00\x00\x00\x00\x00\x00'
tRp147
sg84
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp148
sg86
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp149
stRp150
ag1
(g76
g44
(dp151
g78
g90
sg80
g81
(g82
S'\xf8\xff\xff\xff\xff\xff\xff\xff'
tRp152
sg84
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp153
sg86
g81
(g82
S'\xb4\x00\x00\x00\x00\x00\x00\x00'
tRp154
stRp155
ag1
(g76
g44
(dp156
g78
g106
sg80
g81
(g82
S'\x08\x00\x00\x00\x00\x00\x00\x00'
tRp157
sg84
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp158
sg86
g81
(g82
S'\xb4\x00\x00\x00\x00\x00\x00\x00'
tRp159
stRp160
ag1
(g76
g44
(dp161
g78
g106
sg80
g81
(g82
S'\xf8\xff\xff\xff\xff\xff\xff\xff'
tRp162
sg84
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp163
sg86
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp164
stRp165
ag1
(g76
g44
(dp166
g78
g90
sg80
g81
(g82
S'\xf8\xff\xff\xff\xff\xff\xff\xff'
tRp167
sg84
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp168
sg86
g81
(g82
S'\xb4\x00\x00\x00\x00\x00\x00\x00'
tRp169
stRp170
ag1
(g76
g44
(dp171
g78
g79
sg80
g81
(g82
S'\x08\x00\x00\x00\x00\x00\x00\x00'
tRp172
sg84
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp173
sg86
g81
(g82
S'\xb4\x00\x00\x00\x00\x00\x00\x00'
tRp174
stRp175
ag1
(g76
g44
(dp176
g78
g79
sg80
g81
(g82
S'\x08\x00\x00\x00\x00\x00\x00\x00'
tRp177
sg84
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp178
sg86
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp179
stRp180
ag1
(g76
g44
(dp181
g78
g90
sg80
g81
(g82
S'\xf8\xff\xff\xff\xff\xff\xff\xff'
tRp182
sg84
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp183
sg86
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp184
stRp185
asS'seed'
p186
NsS'thisIndex'
p187
I0
sS'thisN'
p188
I-1
sS'thisTrialN'
p189
I-1
sS'nTotal'
p190
I20
sS'_warnUseOfNext'
p191
I01
sbag1
(g32
g3
NtRp192
(dp193
g35
Vfrom psychopy import visual, event, core, data, gui, logging\u000aimport random\u000aimport os\u000aimport pickle\u000a\u000avers = '2.0'\u000a\u000a\u000a####### PARAMS + SUB INFO #########\u000a\u000a# clocks\u000aglobalClock = core.Clock()\u000alogging.setDefaultClock(globalClock)\u000a\u000a# objects sizes\u000afixationSize = 0.5\u000aprobeSize = 7\u000acueSize = 1\u000a\u000a# nuber of runs\u000arepetitions = 3\u000a\u000a# info dictionary\u000ainfo = {}\u000ainfo['participant'] = ''\u000ainfo['run'] = ''\u000adlg = gui.DlgFromDict(info)\u000aif not dlg.OK:\u000a    core.quit()\u000ainfo['dateStr']= data.getDateStr()[0:11]\u000a\u000a\u000a# subject directory\u000adir_name = info['participant'] + '_' + info['dateStr']\u000adir_check = 'data/' + dir_name\u000a\u000a# if subject directory does not exist, create it\u000aif not os.path.exists(dir_check):\u000a    os.makedirs(dir_check)\u000a\u000a# filenames \u000afilename = "data/" + dir_name + '/'+ info['participant'] + '_' + info['run'] + '_' + info['dateStr'] \u000alogFileName = "data/" + dir_name + '/' + info['participant'] + '_' + info['run'] + '_' + info['dateStr'] + '.log'\u000a\u000a\u000a# stim dirs\u000adir1 = 'selected_images/'\u000adir2 = 'gray_scene/'\u000a\u000a#instructions \u000ainstructPractice = 'Practice about to start. Press RETURN when ready'\u000ainstructExp = 'Experiment about to start. Press RETURN when ready'\u000ainstructMem = 'Memory task about to start. Press RETURN when ready'\u000ainstructThanks = 'Thank you for your participation!'\u000a\u000a#logging\u005cdebugging preferences\u000aDEBUG = False\u000a\u000aif DEBUG:\u000a    fullscr = False\u000a    logging.console.setLevel(logging.DEBUG)\u000aelse:\u000a    fullscr = True\u000a    logging.console.setLevel(logging.WARNING)\u000a\u000alogDat = logging.LogFile (logFileName, filemode='w', level = logging.DATA)\u000a\u000a\u000a\u000a# create window\u000awin = visual.Window([1024,768], fullscr = True, monitor = 'testMonitor', units='deg', color = 'black')\u000a\u000a# obtain frame rate\u000afRate_secs = win.getActualFrameRate()\u000aprint(fRate_secs)\u000a\u000a# set stim display durations\u000ainfo['fixFrames'] = int(round(1.5 * fRate_secs))\u000ainfo['cueFrames'] = int(round(.5 * fRate_secs))\u000ainfo['cuePauseFrames'] = int(round(.2* fRate_secs))\u000ainfo['probeFrames'] = int(round(.2 * fRate_secs))\u000ainfo['cuePos'] = 10\u000ainfo['probePos'] = 10\u000ainfo['memFrames'] = int(round(1 * fRate_secs))\u000a#info['ratingFrames'] = int(round(1 *  fRate_secs))\u000a#^^change this in the rating settings\u000ainfo['memPauseFrames'] = int(round(1 *fRate_secs))\u000a\u000a#create objects\u000afixation = visual.Circle(win, size = fixationSize, lineColor = 'white', fillColor = 'lightGrey')\u000acueVerticesR = [[-.8,-.5], [-.8,.5], [.8,0]]\u000acueRight = visual.ShapeStim(win, vertices = cueVerticesR, lineColor = 'white', fillColor = 'lightGrey')\u000acueVerticesL = [[.8,-.5], [.8,.5], [-.8,0]]\u000acueLeft = visual.ShapeStim(win, vertices = cueVerticesL, lineColor = 'white', fillColor = 'lightGrey')\u000a#cue = visual.Circle(win, size = cueSize, lineColor = 'white', fillColor = 'lightGrey')\u000ainstruction = visual.TextStim(win)\u000a\u000a#import conditions from csv\u000a#should be an even number\u000aconditions = data.importConditions('conditions_short.csv') \u000a#\u000a# KZ : ^ideally run independent of csv file (low priority)\u000a#      currently, csv gives us only # of trials\u000a#\u000atrials = data.TrialHandler(trialList = conditions, nReps = 1)\u000a\u000a##########################################################\u000a\u000a#define practice run (same length as full run)\u000aconditionsPractice = data.importConditions('conditions_short.csv')\u000apractice = data.TrialHandler(trialList = conditionsPractice, nReps = 1)\u000a\u000athisExp = data.ExperimentHandler(name='Posner', version= vers, #not needed, just handy\u000a    extraInfo = info, #the info we created earlier\u000a    dataFileName = filename, # using our string with data/name_date\u000a    )\u000a\u000athisExp.addLoop(trials)\u000athisExp.addLoop(practice)\u000a\u000arespClock = core.Clock()\u000a\u000a\u000a\u000a####### FILE LOAD FUNCTIONS #########\u000a\u000adef get_files(dir_name):\u000a    '''returns all subj pkl files'''\u000a    files = [dir_name + '/' + f for f in os.listdir(dir_name) if f.endswith('.pkl')]\u000a    return files\u000a    \u000adef concat_dicts(dicts):\u000a    big_dict = {}\u000a    for k in dicts[0]:\u000a        big_dict[k] = [d[k] for d in dicts]\u000a    return big_dict\u000a\u000adef load_memP(pickles):\u000a    ''' returns list of memory pkl dicts'''\u000a    mem = []\u000a    for f in pickles:\u000a        if f.endswith('mem_items.pkl'):\u000a            mem.append(f)\u000a            \u000a    mem_dicts = []\u000a    for memf in mem:\u000a        with open(memf, 'rb') as fp:\u000a            x=pickle.load(fp)\u000a        mem_dicts.append(x)\u000a    mem_dict = concat_dicts(mem_dicts)\u000a    return mem_dict\u000a    \u000a    \u000adef load_prevP(pickles):\u000a    '''returns list of prev pkl files'''\u000a    prev = []\u000a    for f in pickles:\u000a        if f.endswith('previous_items.pkl'):\u000a            prev.append(f)\u000a\u000a            \u000a    prev_dicts = []\u000a    for prevf in prev:\u000a        with open(prevf, 'rb') as fp:\u000a            y=pickle.load(fp)\u000a        prev_dicts.append(y)\u000a    prev_dict = concat_dicts(prev_dicts)\u000a    return prev_dict\u000a    \u000a############ EXP FUNCTIONS ############\u000a\u000adef showInstructions(text, acceptedKeys = None):\u000a    """Presents a question and waits for acceptedKeys"""\u000a    \u000a    # Set and display text\u000a    instruction.setText(text)\u000a    instruction.draw()\u000a    win.flip()\u000a    \u000a    # Wait for response and return it\u000a    response = event.waitKeys(keyList=acceptedKeys)\u000a    #return response\u000a    if response == 'escape':\u000a        core.quit()\u000a\u000a\u000adef presBlock( pickle_name, prev_stim, run, loop = object, saveData = True, test=True):\u000a\u000a    """Runs a loop for an experimental block and saves reponses if requested"""\u000a    \u000a    trialClock = core.Clock()\u000a    \u000a    previous_items = {}\u000a    cued = []\u000a    uncued = []\u000a    cue_right = []\u000a    \u000a    reaction_time={}\u000a    cued_RT = []\u000a    uncued_RT = []\u000a    \u000a    trial_count = 0\u000a    \u000a    for thisTrial in loop:\u000a        \u000a        trial_count += 1\u000a        \u000a        # [1] CUE ONE SIDE\u000a        \u000a        #randomize side\u000a        if bool(random.getrandbits(1)) == True:\u000a            cue = cueRight\u000a            cue_right.append(1)\u000a\u000a        else:\u000a            cue = cueLeft\u000a            cue_right.append(0)\u000a            \u000a        cue.setPos( [0, 0] )\u000a        \u000a        #show fixation\u000a        fixation.setAutoDraw(True)\u000a        for frameN in range(info['fixFrames']):\u000a            win.flip()\u000a        \u000a        #show cue\u000a        cue.setAutoDraw(True)\u000a        for frameN in range(info['cueFrames']):\u000a            win.flip()\u000a        cue.setAutoDraw(False) \u000a        \u000a        #pause\u000a        for frameN in range(info['cuePauseFrames']):\u000a            fixation.setAutoDraw(True)\u000a            win.flip()\u000a        \u000a        # [2] DETERMINE TRIAL TYPE (STANDARD vs CATCH)\u000a        #trialType = random.choice([1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2])\u000a\u000a        # [3] RUN TRIAL\u000a        all_items = os.listdir(dir1)+os.listdir(dir2)\u000a        available_items = [x for x in all_items if (x not in cued and x not in uncued and x not in prev_stim)]\u000a            \u000a        #select and load image stimuli at random\u000a        #select and load image stimuli at random\u000a        img1_file = random.choice([x for x in available_items if x in os.listdir(dir1)])\u000a        img1 = dir1+img1_file\u000a        img2_file = img1_file\u000a           \u000a        while (img2_file == img1_file):\u000a            img2_file = random.choice([x for x in available_items if x in os.listdir(dir2)])\u000a            \u000a        img2 = dir2 + img2_file\u000a        \u000a        #assign images as probes (w/ sizes, locations, etc.)\u000a        if random.choice([0,1])==True:\u000a            probe1 = visual.ImageStim(win, img1, size=probeSize) #pos=(5, 0), size=probeSize)\u000a            probe2 = visual.ImageStim(win, img2, size=probeSize) #pos=(-5, 0), size=probeSize)\u000a        else:\u000a            probe2 = visual.ImageStim(win, img1, size=probeSize) #pos=(5, 0), size=probeSize)\u000a            probe1 = visual.ImageStim(win, img2, size=probeSize) #pos=(-5, 0), size=probeSize)\u000a        \u000a        probePos = random.choice([1,2])\u000a        \u000a        if probePos == 1:\u000a            pos1 = info['probePos']\u000a            pos2 = -info['probePos']\u000a            \u000a        else:\u000a            pos1 = -info['probePos']\u000a            pos2 = info['probePos']\u000a         \u000a        probe1.setPos([pos1, 0])\u000a        probe2.setPos([pos2, 0])\u000a         \u000a        if (cue == cueRight and pos1 > 0) :\u000a            cued.append(img1_file)\u000a            uncued.append(img2_file)\u000a        else:\u000a            cued.append(img2_file)\u000a            uncued.append(img1_file)\u000a        \u000a        #response and reaction time variables\u000a        resp = None\u000a        rt = None\u000a        \u000a        #display probes simultaneously\u000a        probe1.setAutoDraw(True)\u000a        probe2.setAutoDraw(True)\u000a        win.callOnFlip(respClock.reset)\u000a        event.clearEvents()\u000a        for frameN in range(info['probeFrames']):\u000a            if frameN == 0:\u000a                respClock.reset()\u000a            win.flip()\u000a        probe1.setAutoDraw(False)\u000a        probe2.setAutoDraw(False)\u000a        fixation.setAutoDraw(False)\u000a    \u000a        #clear screen\u000a        win.flip()\u000a        \u000a            #KZ : code below from the original repo\u000a            #     maybe useful format for saving\u000a            #####################################\u000a#                trials.addData('resp', resp)\u000a#                trials.addData('rt', rt)\u000a#                trials.addData('corr', corr)\u000a#                thisExp.nextEntry()\u000a            #####################################\u000a                \u000a             \u000a            \u000a        #if trialType == 1: #if catch trial (30% chance):\u000a                #pause\u000a                \u000a        #for frameN in range(info['cuePauseFrames']):\u000a            #win.flip()\u000a\u000a        resp = None\u000a        rt = None\u000a        \u000a        probe = visual.TextStim(win=win, ori=0, name='fixation', text='+', font='Arial', height = 5.5, color='lightGrey', colorSpace='rgb', opacity=1, depth=0.0)\u000a        if cue == cueRight:\u000a            position = random.choice( [-10, -10, -10, 10, 10, 10, 10, 10, 10, 10] )\u000a        else:\u000a            position = random.choice( [10, 10, 10, -10, -10, -10, -10, -10, -10, -10] )\u000a        probe.setPos( [position, 0] )\u000a        #display probe, break is response recorded\u000a        fixation.setAutoDraw(True)\u000a        probe.setAutoDraw(True)\u000a        win.callOnFlip(respClock.reset)\u000a        event.clearEvents()\u000a        for frameN in range(info['probeFrames']):\u000a            #fixation.setAutoDraw(True)\u000a            #probe.setAutoDraw(True)\u000a            if frameN == 0:\u000a                respClock.reset()\u000a                keys = event.getKeys(keyList = ['enter'])\u000a                if len(keys) > 0:\u000a                    resp = keys[0]\u000a                    rt = respClock.getTime()\u000a                    break\u000a                    \u000a            #clear screen\u000a            win.flip()\u000a            probe.setAutoDraw(False)\u000a            fixation.setAutoDraw(False)\u000a\u000a            #if no response, wait w/ blank screen until response\u000a            if (resp == None and test==False):\u000a                keys = event.waitKeys(keyList = ['1', '3'])\u000a                resp = keys[0]\u000a                rt = respClock.getTime()\u000a            \u000a            elif (resp == None and test == True):\u000a                rt = 'test'\u000a                \u000a            # KZ : reaction times saved below\u000a            #      currently saves two groups: cued/uncued\u000a            #      change to save into four:\u000a            #           2 (cued/uncued) * 2 (right/left) = 4\u000a            \u000a        if ( cue == cueRight and position > 1 ):\u000a            cued_RT.append(rt)\u000a            \u000a        else:\u000a            uncued_RT.append(rt)\u000a            #target_right.append(0)\u000a            #clear screen upon response\u000a            win.flip()\u000a            \u000a\u000a            #KZ : code below from the original repo\u000a            #     maybe useful format for saving\u000a            #####################################\u000a#                trials.addData('resp', resp)\u000a#                trials.addData('rt', rt)\u000a#                trials.addData('corr', corr)\u000a#                thisExp.nextEntry()\u000a            #####################################\u000a                \u000a        win.flip()\u000a    \u000a    previous_items['cued'] = cued\u000a    previous_items['uncued'] = uncued\u000a    previous_items['uncued_RT'] = uncued_RT\u000a    previous_items['cued_RT'] = cued_RT\u000a    previous_items['cued_RT'] = cued_RT\u000a    previous_items['cue_Right'] = cue_right\u000a    previous_items['run_time'] = trialClock.getTime()\u000a    previous_items['total_iters'] = trial_count\u000a    \u000a    # KZ : code below saves data in pickle format\u000a    #      if we save data per trial (we should, even if not needed; want a record of everything subject saw at each moment) \u000a    #      we will need to incorporate trial # and subject # into filenames\u000a    \u000a    #      should set up experiment so that if subject is on run 1, it makes new directory for subject\u000a    #      other runs --> check for directory --> if exists, save out to subj dir --> if not exist..warning? create subject direcotry?\u000a    \u000a    with open(pickle_name, 'wb') as f:\u000a        pickle.dump(previous_items, f)\u000a\u000a\u000a\u000a\u000a\u000adef memBlock( conds, current_pickle, prev_stim ):\u000a    trialClock = core.Clock()\u000a    \u000a    # start dictionary to store data\u000a    mem_task = {}\u000a    \u000a    # filename for saved output\u000a    pickle_name_mem = "data/" + dir_name + '/' + info['participant'] + '_' + info['run'] + '_' + info['dateStr'] + 'mem_items.pkl'\u000a    \u000a    #KZ : reads in the pickle file\u000a    with open(current_pickle,'rb') as fp:\u000a        current_list = pickle.load(fp)\u000a        #previous_items_full = [val for sublist in previous_items for val in sublist]\u000a    \u000a    \u000a    # empty list to store items used in memory task\u000a    previous_mem = []\u000a    all_ratings = []\u000a    \u000a    \u000a    for each in conds:\u000a        \u000a        all_items = os.listdir(dir1)+os.listdir(dir2)\u000a        available_attended = [x for x in current_list['cued'] if x not in previous_mem]\u000a        available_unattended = [x for x in current_list['uncued'] if x not in previous_mem]\u000a        available_random = [x for x in all_items if (x not in previous_mem and x not in current_list['cued'] and x not in current_list['uncued'] and x not in prev_stim)]\u000a        \u000a        #select and load image stimuli \u000a        #options = [ 1, 2, 3]\u000a        options = []\u000a        if len(available_attended)>0:\u000a            options.append(1)\u000a        if len(available_unattended)>0:\u000a            options.append(2)\u000a        if len(available_random)>0:\u000a            options.append(3)\u000a        \u000a        # if we decide not to show all images then will want to show Rpres and Lpres with same frequency\u000a        type = random.choice(options)\u000a        \u000a        if type == 1:\u000a            mem_file = random.choice(available_attended)\u000a        elif type == 2:\u000a            mem_file = random.choice(available_unattended)\u000a        else:\u000a            mem_file = random.choice(available_random)\u000a        \u000a        try:\u000a            #Type = 'Faces'\u000a            #mem = '/Users/kirstenziman/Documents/GitHub/P4N2016/stim/OddballLocStims/'+Type+'/'+mem_file\u000a            mem = dir1 + mem_file\u000a            memProbe = visual.ImageStim( win, mem, size=probeSize )\u000a            memProbe.setPos( [0, 0] )\u000a            \u000a        except:\u000a            #Type = 'Houses'\u000a            #mem = '/Users/kirstenziman/Documents/GitHub/P4N2016/stim/OddballLocStims/'+Type+'/'+mem_file\u000a            mem = dir2 + mem_file\u000a            memProbe = visual.ImageStim( win, mem, size=probeSize )\u000a            memProbe.setPos( [0, 0] )\u000a\u000a        \u000a        win.callOnFlip(respClock.reset)\u000a        event.clearEvents()\u000a\u000a        for frameN in range(info['memFrames']):\u000a            memProbe.setAutoDraw(True)\u000a            if frameN == 0:\u000a                respClock.reset()\u000a            win.flip()\u000a        memProbe.setAutoDraw(False)\u000a        win.flip()\u000a        \u000a#        for frameN in range(info['memFrames']):\u000a#            memProbe.setAutodraw(True)\u000a#        win.flip()\u000a        \u000a        ratingScale = visual.RatingScale( win, low = 1, high = 4, labels = ['viewed before','new image'], scale = None, pos = [0,0],acceptPreText='', maxTime=1.0, singleClick=True)\u000a        \u000a        ##################\u000a\u000a        while ratingScale.noResponse:\u000a            #item.draw()\u000a            ratingScale.draw()\u000a            win.flip()\u000a        choiceHistory = ratingScale.getHistory()\u000a\u000a        for frameN in range(info['memPauseFrames']):\u000a            fixation.setAutoDraw(True)\u000a            win.flip()\u000a        fixation.setAutoDraw(False)\u000a\u000a        # KZ : need to save decisionTime and choiceHistory\u000a        #      need to save decisionTime grouped by type of image subj is responding to\u000a        #      10 image types : 1 (seen) * 2 (attended/unattended) * 2 (displayed right/left) * 2 (face/house)  +  1 (unseen) * 2 (face/house)\u000a        \u000a        previous_mem.append(mem_file)\u000a        all_ratings.append(choiceHistory)\u000a    \u000a    mem_task['ratings'] = all_ratings\u000a    mem_task['images'] = previous_mem\u000a    mem_task['run_time'] = trialClock.getTime()\u000a    mem_task['total_iters'] = conds\u000a    #mem_task['choiceHist']=all_ratings\u000a\u000a    with open(pickle_name_mem, 'wb') as f:\u000a        pickle.dump(mem_task, f)\u000a        \u000a        \u000a        \u000a######### RUN EXPERIMENT ###########\u000a\u000a# for specified number of reps, run presentation them memory\u000afor rep in range(0,repetitions):\u000a    \u000a    #pickle_name for use in both functions\u000a    pickle_name = "data/" + dir_name + '/' + info['participant'] + '_' + info['run'] + '_' + info['dateStr'] + 'previous_items.pkl'\u000a    \u000a    # if pkl files exist from previous runs, load the data\u000a    prev_runs = []\u000a    files = get_files(dir_check)\u000a    if len(files)>0:\u000a        mem_dict = load_memP(files)\u000a        prev_dict = load_prevP(files)\u000a        \u000a        prev_stim = mem_dict['images']\u000a        prev_stim.append(prev_dict['cued'])\u000a        prev_stim.append(prev_dict['uncued'])\u000a        prev_stim = [val for sublist in prev_stim for val in sublist]\u000a    else:\u000a        prev_stim = []\u000a    #prev_stim list of all images shown BEFORE THIS TRIAL\u000a        \u000a    # load trials\u000a    conditions = data.importConditions('conditions_short.csv') \u000a    trials = data.TrialHandler(trialList = conditions, nReps = 1)\u000a\u000a    #presentation task\u000a    showInstructions(text = instructExp, acceptedKeys = ['1','2','3','4','return', 'escape'])\u000a    presBlock(pickle_name, prev_stim, info['run'], trials, test=False)\u000a#    presBlock(info['run'], trials)\u000a\u000a    #memory task\u000a    showInstructions(text = instructMem, acceptedKeys = ['1','2','3','4','return'])\u000a    memBlock(range(0,len(conditions)*3), pickle_name, prev_stim)\u000a    \u000a    info['run'] = str(int(info['run'])+1)\u000a\u000a#closing message\u000ashowInstructions(text = instructThanks, acceptedKeys = ['1','2','3','4','return'])
p194
sg37
(lp195
sg39
I328834448
sg10
S''
sg6
g40
sg41
I0
sg14
I01
sg15
Nsg42
g1
(g43
g44
(dp196
g46
g47
(g48
g49
g50
S'b'
tRp197
(I1
(I20
I1
tg53
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
Ntbsg54
g47
(g48
g49
g50
S'b'
tRp198
(I1
(I20
I1
tg53
I00
S'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
S'\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01\x01'
NtbstRp199
(dp200
g58
(dp201
g46
I01
sg54
I01
ssg60
g192
sg61
(lp202
g46
ag54
asg63
(lp203
I20
aI1
asbsg65
g66
sg67
g68
(g49
(I0
tS'b'
tRp204
(I1
(I20
I1
tg70
I01
S'\x00\x00\x00\x00\x06\x00\x00\x00\x05\x00\x00\x00\x07\x00\x00\x00\x13\x00\x00\x00\x0b\x00\x00\x00\t\x00\x00\x00\x0e\x00\x00\x00\x0c\x00\x00\x00\x03\x00\x00\x00\x12\x00\x00\x00\x04\x00\x00\x00\r\x00\x00\x00\x02\x00\x00\x00\x08\x00\x00\x00\x0f\x00\x00\x00\x10\x00\x00\x00\n\x00\x00\x00\x01\x00\x00\x00\x11\x00\x00\x00'
tbsg71
I00
sg72
I1
sg73
I20
sg74
(lp205
g1
(g76
g44
(dp206
S'other'
p207
S'right'
p208
sS'probeX'
p209
g81
(g82
S'\x08\x00\x00\x00\x00\x00\x00\x00'
tRp210
sS'valid'
p211
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp212
sS'cueOri'
p213
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp214
stRp215
ag1
(g76
g44
(dp216
g207
S'left'
p217
sg209
g81
(g82
S'\xf8\xff\xff\xff\xff\xff\xff\xff'
tRp218
sg211
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp219
sg213
g81
(g82
S'\xb4\x00\x00\x00\x00\x00\x00\x00'
tRp220
stRp221
ag1
(g76
g44
(dp222
g207
g208
sg209
g81
(g82
S'\x08\x00\x00\x00\x00\x00\x00\x00'
tRp223
sg211
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp224
sg213
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp225
stRp226
ag1
(g76
g44
(dp227
g207
g217
sg209
g81
(g82
S'\xf8\xff\xff\xff\xff\xff\xff\xff'
tRp228
sg211
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp229
sg213
g81
(g82
S'\xb4\x00\x00\x00\x00\x00\x00\x00'
tRp230
stRp231
ag1
(g76
g44
(dp232
g207
S'conflict'
p233
sg209
g81
(g82
S'\x08\x00\x00\x00\x00\x00\x00\x00'
tRp234
sg211
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp235
sg213
g81
(g82
S'\xb4\x00\x00\x00\x00\x00\x00\x00'
tRp236
stRp237
ag1
(g76
g44
(dp238
g207
g233
sg209
g81
(g82
S'\xf8\xff\xff\xff\xff\xff\xff\xff'
tRp239
sg211
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp240
sg213
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp241
stRp242
ag1
(g76
g44
(dp243
g207
g217
sg209
g81
(g82
S'\xf8\xff\xff\xff\xff\xff\xff\xff'
tRp244
sg211
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp245
sg213
g81
(g82
S'\xb4\x00\x00\x00\x00\x00\x00\x00'
tRp246
stRp247
ag1
(g76
g44
(dp248
g207
g208
sg209
g81
(g82
S'\x08\x00\x00\x00\x00\x00\x00\x00'
tRp249
sg211
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp250
sg213
g81
(g82
S'\xb4\x00\x00\x00\x00\x00\x00\x00'
tRp251
stRp252
ag1
(g76
g44
(dp253
g207
g208
sg209
g81
(g82
S'\x08\x00\x00\x00\x00\x00\x00\x00'
tRp254
sg211
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp255
sg213
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp256
stRp257
ag1
(g76
g44
(dp258
g207
g217
sg209
g81
(g82
S'\xf8\xff\xff\xff\xff\xff\xff\xff'
tRp259
sg211
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp260
sg213
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp261
stRp262
ag1
(g76
g44
(dp263
g207
g208
sg209
g81
(g82
S'\x08\x00\x00\x00\x00\x00\x00\x00'
tRp264
sg211
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp265
sg213
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp266
stRp267
ag1
(g76
g44
(dp268
g207
g217
sg209
g81
(g82
S'\xf8\xff\xff\xff\xff\xff\xff\xff'
tRp269
sg211
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp270
sg213
g81
(g82
S'\xb4\x00\x00\x00\x00\x00\x00\x00'
tRp271
stRp272
ag1
(g76
g44
(dp273
g207
g208
sg209
g81
(g82
S'\x08\x00\x00\x00\x00\x00\x00\x00'
tRp274
sg211
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp275
sg213
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp276
stRp277
ag1
(g76
g44
(dp278
g207
g217
sg209
g81
(g82
S'\xf8\xff\xff\xff\xff\xff\xff\xff'
tRp279
sg211
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp280
sg213
g81
(g82
S'\xb4\x00\x00\x00\x00\x00\x00\x00'
tRp281
stRp282
ag1
(g76
g44
(dp283
g207
g233
sg209
g81
(g82
S'\x08\x00\x00\x00\x00\x00\x00\x00'
tRp284
sg211
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp285
sg213
g81
(g82
S'\xb4\x00\x00\x00\x00\x00\x00\x00'
tRp286
stRp287
ag1
(g76
g44
(dp288
g207
g233
sg209
g81
(g82
S'\xf8\xff\xff\xff\xff\xff\xff\xff'
tRp289
sg211
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp290
sg213
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp291
stRp292
ag1
(g76
g44
(dp293
g207
g217
sg209
g81
(g82
S'\xf8\xff\xff\xff\xff\xff\xff\xff'
tRp294
sg211
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp295
sg213
g81
(g82
S'\xb4\x00\x00\x00\x00\x00\x00\x00'
tRp296
stRp297
ag1
(g76
g44
(dp298
g207
g208
sg209
g81
(g82
S'\x08\x00\x00\x00\x00\x00\x00\x00'
tRp299
sg211
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp300
sg213
g81
(g82
S'\xb4\x00\x00\x00\x00\x00\x00\x00'
tRp301
stRp302
ag1
(g76
g44
(dp303
g207
g208
sg209
g81
(g82
S'\x08\x00\x00\x00\x00\x00\x00\x00'
tRp304
sg211
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp305
sg213
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp306
stRp307
ag1
(g76
g44
(dp308
g207
g217
sg209
g81
(g82
S'\xf8\xff\xff\xff\xff\xff\xff\xff'
tRp309
sg211
g81
(g82
S'\x01\x00\x00\x00\x00\x00\x00\x00'
tRp310
sg213
g81
(g82
S'\x00\x00\x00\x00\x00\x00\x00\x00'
tRp311
stRp312
asg186
Nsg187
I0
sg188
I-1
sg189
I-1
sg190
I20
sg191
I01
sbasS'saveWideText'
p313
I01
sS'thisEntry'
p314
(dp315
sS'version'
p316
S'2.0'
p317
sS'_paramNamesSoFar'
p318
(lp319
sS'entries'
p320
(lp321
sS'loops'
p322
(lp323
g33
ag192
asS'savePickle'
p324
I00
sb.